name: Production Deployment

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:

env:
  DOCKER_ORG: africanalyzer
  APP_NAME: repo1
  REGISTRY: docker.io

jobs:
  # ── Job 1: Run Tests ──────────────────────────────────────────────────────
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    services:
      redis:
        image: redis:7-alpine
        ports: ['6379:6379']
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'requirements/requirements.txt'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install --no-cache-dir -r requirements/requirements.txt
          pip install --no-cache-dir -r requirements/requirements-dev.txt

      - name: Run tests
        env:
          REDIS_URL: redis://localhost:6379/0
          ADMIN_API_KEY: test-key
        run: |
          pytest tests/ -v --cov=src --cov-report=xml

      - name: Security scan
        run: |
          pip install bandit safety
          bandit -r src/ -f json -o bandit-report.json || true
          safety check --json --output safety-report.json || true

      - name: Upload reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json
            coverage.xml

  # ── Job 2: Build & Push Docker Image ──────────────────────────────────────
  build:
    name: Build & Push Docker Image
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_ORG }}/${{ env.APP_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,format=short,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        if: success()
        with:
          image: ${{ env.DOCKER_ORG }}/${{ env.APP_NAME }}@${{ steps.build.outputs.digest }}
          platform: linux/amd64
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: sbom
          path: sbom.spdx.json

  # ── Job 3: Deploy to Production Server ────────────────────────────────────
  deploy:
    name: Deploy to Production
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    # environment: production 

    steps:
      - name: Set Short SHA
        id: vars
        run: echo "short_sha=sha-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_TAG: ${{ steps.vars.outputs.short_sha }}
          DOCKER_ORG_ENV: ${{ env.DOCKER_ORG }}
          APP_NAME_ENV: ${{ env.APP_NAME }}
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: 22
          envs: IMAGE_TAG,DOCKER_ORG_ENV,APP_NAME_ENV
          script_stop: true
          script: |
            echo "========================================="
            echo "  Deploying ${DOCKER_ORG_ENV}/${APP_NAME_ENV}"
            echo "  Image tag: ${IMAGE_TAG}"
            echo "========================================="

            APP_DIR="/opt/intelligence-analyzer"
            COMPOSE_FILE="${APP_DIR}/docker/docker-compose-prod.yml"

            # Ensure app directory exists
            mkdir -p "${APP_DIR}"
            cd "${APP_DIR}"

            # Clone or pull latest code
            if [ ! -d ".git" ]; then
              echo ">> Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git .
            else
              echo ">> Pulling latest changes..."
              git fetch origin main
              git reset --hard origin/main
            fi

            # Create required directories
            mkdir -p logs reports
            chmod 755 logs reports

            # Update image tag in compose file
            echo ">> Setting image to ${DOCKER_ORG_ENV}/${APP_NAME_ENV}:${IMAGE_TAG}"
            sed -i "s|image: .*${APP_NAME_ENV}:.*|image: ${DOCKER_ORG_ENV}/${APP_NAME_ENV}:${IMAGE_TAG}|g" "${COMPOSE_FILE}"

            # Login to Docker Hub
            echo ">> Logging into Docker Hub..."
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

            # Pull new images
            echo ">> Pulling new images..."
            docker compose -f "${COMPOSE_FILE}" pull

            # Start new containers
            echo ">> Starting new containers..."
            docker compose -f "${COMPOSE_FILE}" up -d

            # Wait for containers to be ready
            echo ">> Waiting 15s for startup..."
            sleep 15

            # Health check
            echo ">> Running health check..."
            HEALTHY=false
            for i in $(seq 1 10); do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                HEALTHY=true
                echo ">> Health check passed!"
                break
              fi
              echo ">> Attempt ${i}/10 - got HTTP ${HTTP_CODE}, retrying in 5s..."
              sleep 5
            done

            if [ "$HEALTHY" = "true" ]; then
              echo "========================================="
              echo "  DEPLOYMENT SUCCESSFUL"
              echo "========================================="
              docker compose -f "${COMPOSE_FILE}" ps
            else
              echo "========================================="
              echo "  DEPLOYMENT FAILED"
              echo "========================================="
              docker compose -f "${COMPOSE_FILE}" logs --tail=50
              exit 1
            fi

            # Cleanup
            docker image prune -f
            docker logout

  # ── Job 4: Notify ─────────────────────────────────────────────────────────
  notify:
    name: Notify Deployment Status
    needs: [test, build, deploy]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Repo:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests:** ${{ needs.test.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build:** ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy:** ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
